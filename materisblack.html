<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<title>2 kule – stabilna grawitacja + miękkie lejki</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    font-family: system-ui, sans-serif;
    color: #eee;
  }
  #canvasContainer {
    width: 100vw;
    height: 100vh;
  }
  #ui {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    pointer-events: none;
    display: flex;
    justify-content: flex-start;
  }
  #panel {
    pointer-events: auto;
    background: rgba(10,10,20,0.9);
    padding: 8px 10px;
    margin: 8px;
    border-radius: 8px;
    border: 1px solid rgba(120,200,255,0.25);
    font-size: 12px;
    max-width: 220px;
  }
  #panel input[type=range] { width: 100%; }
  .label { font-size: 11px; opacity: 0.8; margin-top: 4px; }
  .value { font-weight: 600; color: #9fe3ff; }
</style>
</head>
<body>
<div id="canvasContainer"></div>

<div id="ui">
  <div id="panel">

    <div class="label">Szybkość czasu</div>
    <input id="timeScaleSlider" type="range" min="1" max="400" value="15">
    <div class="value" id="timeScaleValue">0.15×</div>

    <div class="label">Masa (głębokość lejka)</div>
    <input id="massSlider" type="range" min="1" max="400" value="60">
    <div class="value" id="massValue">0.60×</div>

    <div class="label">Szerokość lejka</div>
    <input id="wellWidthSlider" type="range" min="1" max="400" value="300">
    <div class="value" id="wellWidthValue">3.00×</div>

    <div class="label">Siła grawitacji</div>
    <input id="gravitySlider" type="range" min="1" max="400" value="100">
    <div class="value" id="gravityValue">1.00×</div>

  </div>
</div>

<script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
<script>
(function() {

  /* --- PARAMETRY --- */
  const BASE_DT = 0.3;   // większe dt → grawitacja działa
  let TIME_SCALE = 0.15;

  let MASS_SCALE = 0.60;
  let WELL_WIDTH = 3.00;
  let G_SCALE = 1.00;

  const BASE_G = 0.5;  // stabilna, realistyczna grawitacja

  const WELL_RES   = 120;
  const WELL_RANGE = 400;

  const ROOM_SIZE = 350;

  /* --- SCENA --- */
  const container = document.getElementById("canvasContainer");
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(
    55, window.innerWidth / window.innerHeight, 0.1, 5000
  );
  camera.position.set(0, 350, 900);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const light = new THREE.PointLight(0xffffff, 1.2);
  light.position.set(0, 400, 400);
  scene.add(light);

  /* --- ZOOM SCROLLEM --- */
  window.addEventListener("wheel", e => {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    camera.position.addScaledVector(dir, e.deltaY * 0.5);
  });

  /* --- SIATKA --- */
  const floorGeom = new THREE.PlaneGeometry(
    WELL_RANGE * 2, WELL_RANGE * 2, WELL_RES - 1, WELL_RES - 1
  );
  floorGeom.rotateX(-Math.PI / 2);

  const floorMat = new THREE.MeshBasicMaterial({
    color: 0x111a2a,
    wireframe: false,
    transparent: true,
    opacity: 0.5
  });
  const floorMesh = new THREE.Mesh(floorGeom, floorMat);
  scene.add(floorMesh);

  const floorWireGeom = floorGeom.clone();
  const floorWireMat = new THREE.MeshBasicMaterial({
    color: 0x335577,
    wireframe: true,
    transparent: true,
    opacity: 0.4
  });
  const floorWire = new THREE.Mesh(floorWireGeom, floorWireMat);
  scene.add(floorWire);

  /* --- KULE --- */
  const balls = [];

  function createBall(opts) {
    const geo = new THREE.SphereGeometry(opts.radius, 32, 32);
    const mat = new THREE.MeshStandardMaterial({ color: opts.color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(opts.position);
    scene.add(mesh);

    const ball = {
      mesh,
      velocity: opts.velocity.clone(),
      color: opts.color
    };
    balls.push(ball);
    return ball;
  }

  /* --- ZMNIEJSZONE PRĘDKOŚCI (10× mniejsze) --- */
  const ball1 = createBall({
    radius: 18,
    color: 0xff5555,
    position: new THREE.Vector3(-150, 0, -80),
    velocity: new THREE.Vector3(4, 0, 2.5)
  });

  const ball2 = createBall({
    radius: 18,
    color: 0x55aaff,
    position: new THREE.Vector3(120, 0, 100),
    velocity: new THREE.Vector3(-3.5, 0, -3)
  });

  /* --- LEJKI (Gauss + clamp + damping) --- */
  function updateGravityWell() {
    const posAttr = floorGeom.attributes.position;
    const posWireAttr = floorWire.geometry.attributes.position;
    const vertex = new THREE.Vector3();

    for (let i = 0; i < posAttr.count; i++) {
      vertex.fromBufferAttribute(posAttr, i);

      const x = vertex.x;
      const z = vertex.z;

      let potential = 0;

      for (const b of balls) {
        let dx = (x - b.mesh.position.x) * WELL_WIDTH;
        let dz = (z - b.mesh.position.z) * WELL_WIDTH;

        let r = Math.sqrt(dx*dx + dz*dz);
        r = Math.max(r, 5);

        const falloff = Math.exp(-(r*r) / (20000));
        potential += -MASS_SCALE * falloff;
      }

      const targetY = potential * 200;

      const oldY = posAttr.getY(i);
      const smoothY = oldY * 0.85 + targetY * 0.15;

      posAttr.setY(i, smoothY);
      posWireAttr.setY(i, smoothY);
    }

    posAttr.needsUpdate = true;
    posWireAttr.needsUpdate = true;
    floorGeom.computeVertexNormals();
    floorWire.geometry.computeVertexNormals();
  }

  /* --- GRAWITACJA MIĘDZY KULKAMI (stabilna) --- */
  function applyGravity(dt) {
    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {

        const A = balls[i];
        const B = balls[j];

        const rVec = B.mesh.position.clone().sub(A.mesh.position);
        let r = rVec.length();
        r = Math.max(r, 5);

        const dir = rVec.normalize();

        const forceMag =
          BASE_G * G_SCALE * MASS_SCALE * MASS_SCALE * 10 / (r * r);

        A.velocity.add(dir.clone().multiplyScalar(forceMag * dt));
        B.velocity.add(dir.clone().multiplyScalar(-forceMag * dt));
      }
    }
  }

  /* --- RUCH --- */
  function updateBalls(dt) {
    applyGravity(dt);

    for (const b of balls) {
      b.mesh.position.addScaledVector(b.velocity, dt);

      if (b.mesh.position.x < -ROOM_SIZE || b.mesh.position.x > ROOM_SIZE) {
        b.velocity.x *= -1;
        b.mesh.position.x = THREE.MathUtils.clamp(b.mesh.position.x, -ROOM_SIZE, ROOM_SIZE);
      }
      if (b.mesh.position.z < -ROOM_SIZE || b.mesh.position.z > ROOM_SIZE) {
        b.velocity.z *= -1;
        b.mesh.position.z = THREE.MathUtils.clamp(b.mesh.position.z, -ROOM_SIZE, ROOM_SIZE);
      }
    }
  }

  /* --- UI --- */
  timeScaleSlider.oninput = () => {
    TIME_SCALE = parseFloat(timeScaleSlider.value) / 100;
    timeScaleValue.textContent = TIME_SCALE.toFixed(2) + "×";
  };

  massSlider.oninput = () => {
    MASS_SCALE = parseFloat(massSlider.value) / 100;
    massValue.textContent = MASS_SCALE.toFixed(2) + "×";
  };

  wellWidthSlider.oninput = () => {
    WELL_WIDTH = parseFloat(wellWidthSlider.value) / 100;
    wellWidthValue.textContent = WELL_WIDTH.toFixed(2) + "×";
  };

  gravitySlider.oninput = () => {
    G_SCALE = parseFloat(gravitySlider.value) / 100;
    gravityValue.textContent = G_SCALE.toFixed(2) + "×";
  };

  /* --- ANIMACJA --- */
  function animate() {
    requestAnimationFrame(animate);

    const dt = BASE_DT * TIME_SCALE;
    updateBalls(dt);
    updateGravityWell();

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>
